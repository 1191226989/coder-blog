# 高并发订单号生成方案

1. 唯一性：这是作为订单号最基本的特点
2. 高并发：并发能力越高越好
3. 趋势递增但是不能绝对递增：趋势递增会对现代数据库索引结构更友好，但是不要绝对递增是因为绝对递增的话，很容易暴露系统每天产生的订单量
4. 利于以后的分库分表



### 技术方案

> **timestamp + 类用户ID + 随机数（可选）**

1. 唯一性：这种方案的订单号只有在同一个用户在同一毫秒内下多个订单才会出现出现，很显然对于正常的用户行为，是不可能出现重复的，所以满足唯一性。
2. 高并发：这个设计方案完全不依赖任何第三方服务，只通过一定的规则就能生成。所以这种方案不但高并发而且零消耗。
3. 递增性：因为订单号的前一部分是时间戳，所以满足趋势递增。并且也满足非绝对递增的特性。
4. 分库分表：假设分库分表因子为订单号最后6位数，那么无论是根据订单ID查询，还是根据用户ID查询，都不会涉及跨库跨表，效率非常高。

如果担心用户ID信息通过订单号暴露，可以先通过某种函数例如hash(userId)，然后再生成订单号即可。

作为一个订单表，最核心的查询有3类：**根据订单号查询、根据用户ID查询、根据商户号查询**，这三类查询占了订单表90%甚至更多的查询量。如果采用的是这里提到的时间戳 + 类用户ID的方案，那么根据订单号查询和根据用户ID查询都不涉及跨表，效率非常高。

假设订单表按照订单号进行分表，并且分表算法为：`hash(last6(orderId))%16`，即根据订单号的最后6位数字hash后取模。这样的话，如下几个订单号就会分在同一个表假设t_order_5，因为这几个订单号最后6位数字完全一样：

> 1573172799123 141618
>
> 1575878423467 141618
>
> 1583545280012 141618

然后，这几个订单表都是用户ID为182141618生成的（我们假设hash(182141618)%1000000=141618）。那么用户ID为182141618所生成的订单也会都落在表t_order_5，因为hash(182141618)%1000000=141618。也就是说，查询条件带有userId=182141618的查询目标表都是t_order_5。这种方案就是所谓的**因子分表法**。



### 支付宝订单号方案

下面是3个真实的支付宝订单号（空格是为了更直观的看出支付宝订单号的特点）：

> 20191024 2200141625 1404175790
> 20191025 2200141625 1404414662
> 20191026 2200141625 1405369921

分析这几个支付宝订单号，将其分解为3部分，从而得出支付宝的订单号的特点。

> 时间戳 + 类用户ID + 递增的数值
