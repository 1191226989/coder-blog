---
title: Golang内存模型
created: '2023-12-04T14:45:30.405Z'
modified: '2023-12-08T12:05:42.611Z'
---

# Golang内存模型

#### 一. 简介（Introduction）
Go内存模型涉及到多个`Go`协程之间对同一个变量的读写。

假如有一个变量，其中一个Go协程(a)写这个变量，另一个Go协程(b)读这个变量；Go内存模型定义了在什么情况下Go协程(b)能够确保读取到由Go协程(a) 写入的值。

#### 二. 建议（Advice）
如果多协程并发修改数据，必须保证各个步骤串行执行（序列化访问）。
为了串行执行，可以使用 `channel` 或其他同步原语（`sync`锁 和 `sync/atomic`原子）来保护被共享的数据。

#### 三. 发生在…之前（Happens Before）

##### 3.1 重排序
当只有一个Go协程时，对同一个变量的读写必然是按照代码编写的顺序来执行的。对于多个变量的读写，如果重新排序不影响代码逻辑的正常执行，编译器和处理器可能会对多个变量的读写过程重新排序。

例如对于 `a = 1; b = 2` 这两个语句，在同一个Go协程里先执行哪个其实是没有区别的，只要最后执行结果正确就行。
```go
a := 1//1
b := 2//2
c := a + b //3
```
但是，因为重新排列执行顺序的情况的存在，会导致**某个Go协程所观察到的执行顺序可能与另一个Go协程观察到的执行顺序不一样。** 可能另一个Go协程观察到的事实是 `b` 的值先被更新，而 `a` 的值后更新。

##### 3.2 happens-before
为了表征读写需求，定义 `happens-before`，用来表示 Go 语言中某一小段内存命令的执行顺序。

如果事件 `e1` 发生在事件 `e2` 之前，此时就认为 `e2` 发生在 `e1` 之后。
如果事件 `e1` 既不发生在事件 `e2` 之前，也不发生在 `e2` 之后，此时我们就认为 `e1` 和 `e2` 同时发生（并发）。

##### 3.3 规则
在只有一个Go协程的内部，`happens-before`的顺序就是代码显式定义的顺序。当Go协程有多个的时候，存在下面两个规则：

如果存在一个变量 `v`，下面的两个条件都满足，则读操作 `r` 允许观察到（可能观察到，也可能观察不到）写操作 `w` 写入的值。
- `r` 不在 `w` 之前发生；
- 不存在其他的 `w’` 在 `w` 之后发生，也不存在 `w’` 在 `r` 之前发生。

为了保证读操作 `r` 读取到的是写操作 `w` 写入的值，需要确保 `w` 是唯一允许被 `r` 观察到的写操作。如果下面的两个条件都满足，则 `r` 保证能够观察到 `w` 写入的值：
- `w` 发生在 `r` 之前；
- 其他对共享变量 `v` 的写操作要么发生在 `w` 之前，要么发生在 `r` 之后。

规则二的条件比规则一的条件更为严格，它要求没有其他的写操作和 `w`、`r` 并发地发生。

在一个Go协程里是不存在并发的，因此规则一和规则二是等效的：读操作 `r` 可以观察到最近一次写操作 `w` 写入的值。

但是，当多个协程访问一个共享变量时，就必须使用同步事件来构建 `happens-before` 的条件，从而保证读操作观察到的一定是想要的写操作。

在内存模型中，变量 `v` 的零值初始化操作等同于一个写操作。

如果变量的值大于单机器字（CPU 从内存单次读取的字节数），那么 CPU 在读和写这个变量的时候是以一种不可预知顺序的**多次执行单机器字**的操作，这也是 `sync/atomic` 包存在的价值。

#### 四. 同步（Synchronization）
##### 4.1 初始化（Initialization）
程序的初始化是在一个单独的Go协程中进行的，但是这个协程可以创建其他的Go协程并且二者并发执行。

每个包都允许有一个 `init` 函数，当这个包被导入时，会执行该包的这个 `init` 函数，做一些初始化任务。

如果一个包 `p` 导入了包 `q`， 那么 `q` 的 `init` 函数的执行发生在 `p`的所有 `init` 函数的执行之前。（包的引用链）

函数 `main.main` 的执行发生在所有的 `init` 函数执行完成之后。

##### 4.2 Go协程的创建（Goroutine creation）
通过 `go` 语句启动新的Go协程这个动作，发生在新的Go协程的执行之前。
```go
var a string

func f() {
  print(a)
}

func hello() {
  a = "hello, world"
  go f()
}
```
调用函数 `hello` 会在调用后的某个时间点打印 `hello, world` ，这个时间点可能在 `hello` 函数返回之前，也可能在 `hello` 函数返回之后。

##### 4.3 Go协程的销毁（Goroutine destruction）
Go协程的退出无法确保发生在程序的某个事件之前。
```go
var a string

func hello() {
    go func() { 
      a = "hello" 
    }()
    print(a)
}
```
其中 `a` 的赋值语句没有任何的同步措施，因此无法保证被其他任意的 Go 协程（例如 `hello` 函数本身）观察到这个赋值事件的存在。

一些激进的编译器可能会在编译阶段删除上面代码中的整个 `go` 语句。

如果某个Go协程里发生的事件必须要被另一个Go协程观察到，需要使用同步机制进行保证，比如使用锁或者通道（`channel`）来构建一个相对的事件发生顺序。

#### 4.4 通道通信（Channel communication）
通过 `channel` 实现并发顺序控制。

1. 有缓存channel
在某个特定的通道上发送一个数据，则对应地可以在这个通道上接收一个数据，一般情况下是在不同的Go协程间发送与接收。

- 规则一：在某个通道上发送数据的事件发生在相应的接收事件之前。即一定是先发送数据，才能接收到数据这个顺序。
```go
var c = make(chan int, 10)
var a string

func f() {
  a = "hello, world"
  c <- 0
}

func main() {
  go f()
  <-c
  print(a)
}
```
上面这段代码保证了 `hello, world` 的打印。因为通道的写入事件 `c <- 0` 发生在读取事件 `<-c` 之前，而 `<-c` 发生在 `print(a)`之前。通道未被读取时协程会阻塞。

- 规则二：通道的关闭事件发生在从通道接收到零值（由通道关闭触发）之前。即一定是先关闭 channel，才能接收到零值。
在前面的例子中，可以使用 `close(c)` 来替代 `c <- 0` 语句来保证同样的效果。

2. 无缓存 channel
- 规则三：对于没有缓存的通道，数据的接收事件发生在数据发送完成之前。
即通道容量为`0`时，只有发送的信息被读取了才算发送成功，否则阻塞。
```go
var c = make(chan int) //容量为0，无缓存
var a string

func f() {
  a = "hello, world"
  <-c
}
func main() {
  go f()
  c <- 0
  print(a)
}
```
上面这段代码依然可以保证可以打印 `hello, world`。因为通道的写入事件 `c <- 0` 发生在读取事件 `<-c` 之前，而 `<-c` 发生在写入事件 `c <- 0` 完成之前，同时写入事件 `c <- 0` 的完成发生在 `print` 之前。

如果通道是带缓存的（比如 `c = make(chan int, 1)`），程序将不能保证会打印出 `hello, world`，它可能会打印出空字符串，也可能崩溃退出。

- 规则四：对于容量为 `C` 的通道，接收第 `k` 个元素的事件发生在第 `k+C` 个元素的发送之前。
规则四是规则三在带缓存的通道上的推广。

它使得带缓存的通道可以模拟出计数信号量：**通道中元素的个数表示活跃数，通道的容量表示最大的可并发数；发送一个元素意味着获取一个信号量，接收一个元素意味着释放这个信号量。**这是一种常见的限制并发的用法。

下面的代码给工作列表中的每个入口都开启一个Go协程，但是通过配合一个固定长度的通道保证了同时最多有 3 个运行的工作（最多 3 个并发）。
```go
var limit = make(chan int, 3)

func main() {
  for _, w := range work {
    go func(w func()) {
      limit <- 1  // channel里达到3个即阻塞
      w()
      <-limit  // 取出后channel里小于3个即可继续
    }(w)
  }
  select{}
}
```

#### 五. 锁
`sync` 实现了两类锁数据类型，分别是 `sync.Mutex` 和 `sync.RWMutex`，即互斥锁和读写锁。

- 规则一：对于类型为 `sync.Mutex` 和 `sync.RWMutex` 的变量 `l`，如果存在 `n` 和 `m` 且满足 `n < m`，则 `l.Unlock()` 的第 `n` 次调用返回发生在`l.Lock()` 的第 `m` 次调用返回之前。即先解开上一次锁才能上这一次锁。
```go
var l sync.Mutex
var a string

func f() {
  a = "hello, world"
  l.Unlock()
}

func main() {
  l.Lock()
  go f()
  l.Lock()
  print(a)
}
```
上面这段代码保证能够打印 `hello, world`。`l.Unlock()`的第 1 次调用返回（在函数 `f` 内部）发生在 `l.Lock()` 的第 2 次调用返回之前，后者发生在 `print` 之前。

- 规则二：存在类型 `sync.RWMutex` 的变量 `l`，如果 `l.RLock` 的调用返回发生在 `l.Unlock` 的第 `n` 次调用返回之后，那么其对应的 `l.RUnlock` 发生在 `l.Lock` 的第 `n+1` 次调用返回之前。
读锁可以加锁多次，但是只要没有全部解开就不能上写锁，写锁只能存在一个。

#### 六. 单次运行
包 `sync` 还提供了 `Once` 类型用来保证多协程的初始化的安全。

多个Go协程可以并发执行 `once.Do(f)` 来执行函数 `f`， 且只会有一个Go协程会运行 `f()`，其他的 Go 协程会阻塞到 `f()` 运行结束(不再执行 `f`，但能得到运行结果)

- 规则一：函数 `f()` 在 `once.Do(f)` 的单次调用返回发生在其他所有的 `once.Do(f)` 调用返回之前。
```go
func setup() {
    time.Sleep(time.Second * 2) //1
    a = "hello, world"
    fmt.Println("setup over") //2
}

func doprint() {
    once.Do(setup) //3
    fmt.Println(a) //4
    wg.Done()
}

func twoprint() {
    go doprint()
    go doprint()
}

func main() {
    wg.Add(2)
    twoprint()
    wg.Wait()
}
```
```
setup over
hello, world
hello, world
```
上面代码使用`wg sync.WaitGroup`等待两个`goroutine`运行完毕，由于 `setup over` 只输出一次，所以`setup`方法只运行了一次

`setup` 函数的执行返回发生在所有的 `print` 调用之前，同时会打印出两次 `hello, world`，即当一个`goroutine`在执行`setup`方法的时候，另外一个在阻塞。

#### 七. 不正确的同步方式
##### 7.1 案例一
对某个变量的读操作 `r` 一定概率可以观察到对同一个变量的并发写操作 `w`，但是即使这件事情发生了，也并不意味着发生在 `r` 之后的其他读操作可以观察到发生在 `w` 之前的其他写操作。（这里的先后指的是代码里面声明的操作的先后顺序，而不是实际执行时候的）
```go
var a, b int

func f() {
  a = 1
  b = 2
}

func g() {
  print(b)
  print(a)
}

func main() {
  go f()
  g()
}
```
上面的代码里函数 `g` 可能会先打印 `2`（b的值），然后打印 `0`（a的值）。可能大家会认为既然 `b` 的值已经被赋值为 `2` 了，那么 `a` 的值肯定被赋值为 `1` 了，但事实是两个事件的先后在这里是没有办法确定的，**因为编译器会改变执行顺序**。

##### 7.2 案例二
双重检查锁定尝试避免同步带来的开销。
```go
var a string
var done bool

func setup() {
  a = "hello, world"
  done = true
}

func doprint() {
  if !done {
    once.Do(setup)
  }
  print(a)
}

func twoprint() {
  go doprint()
  go doprint()
}
```
在 `doprint` 函数中，观察到对 `done` 的写操作并不意味着能够观察到对 `a` 的写操作。上面的写法依然有可能打印出空字符串。

##### 7.3 案例三
对某个值的循环检查
```go
var a string
var done bool

func setup() {
    a = "hello, world"
    done = true
}

func main() {
    go setup()
    for !done {
    }
    print(a)
}
```
和上一个例子类似，`main`函数中观察到对 `done` 的写操作并不意味着可以观察到对 `a` 的写操作，因此上面的代码依然可能会打印出空字符串。

更糟糕的是，由于两个Go协程之间缺少同步事件，`main` 函数甚至可能永远无法观察到对 `done` 变量的写操作，导致 `main` 中的 `for` 循环永远执行下去。

上面这个错误有一种变体，如下面的代码所示：
```go
type T struct {
  msg string
}

var g *T

func setup() {
  t := new(T)
  t.msg = "hello, world"
  g = t
}

func main() {
  go setup()
  for g == nil {
  }
  print(g.msg)
}
```
上面的代码即使 `main` 函数观察到 `g != nil` 并且退出了它的 `for` 循环，依然没有办法保证它可以观察到被初始化的 `g.msg` 值。

避免上面几个错误用法的方式是一样的：**显式使用同步语句**。

#### 八. 总结
解决多个goroutine下共享数据可见问题的方法，是在访问共享数据时候施加一定的同步措施。

